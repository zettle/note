# 内置高级类型

## Extract

`Extract<T, U>` 如果 T 是 U 的子类型则返回，不是则返回 never

比如：

```ts
type A = "age" | "name";
type B = "like" | "eat" | "name";
type C = Extract<A, B>; // C=name
```

**源码：**

```ts
type Extract<T, U> = T extends U ? T : never;
```



## Exclude

`Exclude<T, U>` 从 T 中挑出不属于 U 的类型

```ts
type A = "age" | "like";
type B = "like" | "eat";
type C = Exclude<A, B>; // C=age
```

**源码：**

```ts
type Exclude<T, U> = T extends U ? never : T;
```

> 解读：依次判断 `T` 是否在 `U` 内，是的话就不返回，不是的话就返回



## Record

```ts
type A = Record<'name' | 'age', string | number>;
```

**源码：**

```ts
type Record<K extends keyof any, T> = {
    [P in K]: T;
}
```

> 解读：



## Capitalize

首字母转大写

```ts
type A = Capitalize<'aabb'> // A = Aabb
```



## Required

将对象的属性都变成必需的

```ts
interface Person {
  cname?: string;
  age?: number;
}

type A = Required<Person>; // {cname:string; age:number}
```

**源码：**

```typescript
type Required<T> = {
    [P in keyof T]-?: T[P];
};
```

> 解读：上面代码 `P in keyof T` 遍历了对象的属性，给每个属性加`-?`，`-?` 的含义是“删除问号”，



## Partial

将对象的属性变成可选

```ts
interface Person {
  cname: string;
  age: number;
}

type A = Partial<Person>;// {cname?:string; age?:number}
```

**源码：**

```typescript
type Partial<T> = {
    [P in keyof T]?: T[P];
};
```

> 解读：上面代码 `P in keyof T` 遍历了对象的属性，给每个属性加`?`，`?` 的含义是“加上问号”，