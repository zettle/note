# 装饰器

装饰器本质上就是一个函数，可以写入都类、方法、属性、对象上，扩展其功能。

使用装饰器之前，需要在 `tsconfig.json` 将下面配置开启

```json
{
    "experimentalDecorators": true,  /* 启用对传统实验装饰器的实验支持 */
    "emitDecoratorMetadata": true,    /* 为源文件中的装饰声明提供设计类型元数据 */
}
```

## 类装饰器

```ts
function FirstclassDecorator(targetclass: any) {
  console.log("targetclass.name:", targetclass.name);
}
function FirstclassDecorator02(targetclass: any) {
  console.log("FirstclassDecorator02.name:", targetclass.name);
}

@FirstclassDecorator
@FirstclassDecorator02
class CustomerService {
}
```

运行上面代码，可以看到，`@FirstclassDecorator02` 比 `@FirstclassDecorator` 先执行

同时，上面代码并没有`new 类` 进行实例化，说明类装饰器是在类声明的时候就自行的，和实例化没有关系。



等到类被new实例化的时候才执行，可以这么写

```ts
function LoggerDecorator<T extends { new (...arg: any): any }>(targetclass: T) {
  class Logger extends targetclass {
    constructor(...arg: any) {
      super(...arg);
      console.log("日志信息", targetclass.name + "被创建");
    }
  }
  return Logger;
}

@LoggerDecorator
class Test {
  public cname: string;
  constructor(_cname: string) {
    this.cname = _cname;
  }
}

const t = new Test("xiaomign");
```



## 方法装饰器

用在一个方法装饰器上修饰，方法装饰器的执行时机，并不需要等待方法被被执行，而是类声明的时候就执行了	

```ts
function MyMethodDecorator(
  targetClassPrototype: any,
  methodname: string,
  methodDecri: PropertyDescriptor
) {
  console.log("参数1", targetClassPrototype);
  console.log("参数2", methodname);
  console.log("参数3", methodDecri);
  methodDecri.value(); // 执行方法
}

class Person {
  cname: string = "xiaoming";

  @MyMethodDecorator
  sayHello() {
    console.log("this is hello", this.cname);
  }
}
```

方法装饰器的入参含义：

- 参数1：指向该类的原型，上面即是类`Person.prototype`

- 参数2：方法名

- 参数3：该方法的描述符，格式如下

  ```ts
  {
    value: [Function: sayHello], // 方法体
    writable: true,    // 是否可以被修改
    enumerable: false, // 是否可枚举，被for..in 遍历出来
    configurable: true
  }
  ```

**带参数的方法装饰器**

本质上就是一个闭包实现，在上面的方法装饰器再包装一层函数

```ts
function MyMethodDecorator(params: string) {
  return function (targetClassPrototype: any, methodname: string, methodDecri: PropertyDescriptor) {
    // 
  };
}

class Person {
  @MyMethodDecorator("我是参数")
  sayHello() {
    console.log("this is hello");
  }
}
```

**等到调用方法再执行注释器**

前面已经知道，方法装饰器也是在类被生命的时候就自行，如果我们想要等到该方法被调用再执行如何处理？可以使用重写方法的方式实现

并且可以实现 `前置拦截/后置拦截` 的效果

```ts
function MyMethodDecorator(params: string) {
  return function (targetClassPrototype: any,methodname: string,methodDecri: PropertyDescriptor) {
    // 保存原方法，然后重写了
    const targetMethod = methodDecri.value;
    methodDecri.value = function (...args: any[]) {
      console.log("前置拦截");
      targetMethod.apply(this, args);
      console.log("后置拦截");
    };
  };
}

class Person {
  @MyMethodDecorator("我是参数")
  sayHello() {
    console.log("this is hello");
  }
}
```



当同时有属性装饰器、方法装饰器、类装饰器的时候，执行顺序是属性装饰器 - 方法装饰器 - 类装饰器



